#######################################################
# 
# deprec_abstract_file_reader.py
# Python implementation of the Class SensorFileReader
# Generated by Enterprise Architect
# Created on:      09-Jul-2017 21:09:12
# Original author: Laptop
# 
#######################################################
import datetime
from abc import abstractmethod
from collections import defaultdict

from typing import Dict, List

import sensor_file.file_parser.concrete_file_parser as file_parser
from sensor_file.domain.site import Sample, SensorPlateform

sample_ana_type = Dict[str, Sample]
sample_dict = Dict[str, sample_ana_type]
date_list = List[datetime.datetime]


class AbstractFileReader(object):
    """Interface permettant de lire un fichier provenant d'un datalogger quelconque
    classe permettant d'extraire des données d'un fichier quelconque.
    Un fichier de donnée est en général composé de :
    - Entete d'information sur l'environnement de prise de données
    - Entete d'information sur les colonnes de données
    - Les colonnes de données
    """
    TXT_FILE_TYPES = ['dat', 'lev']
    XLS_FILES_TYPES = ['xls', 'xlsx']
    CSV_FILES_TYPES = ['csv']
    WEB_XML_FILES_TYPES = ['xle', 'xml', 'http']
    MONTH_S_DAY_S_YEAR_HMS_DATE_STRING_FORMAT = '%m/%d/%y %H:%M:%S'
    YEAR_S_MONTH_S_DAY_HM_DATE_STRING_FORMAT = '%Y/%m/%d %H:%M'
    YEAR_S_MONTH_S_DAY_HMS_DATE_STRING_FORMAT = YEAR_S_MONTH_S_DAY_HM_DATE_STRING_FORMAT + ":%S"
    YEAR_S_MONTH_S_DAY_HMSMS_DATE_STRING_FORMAT = YEAR_S_MONTH_S_DAY_HMS_DATE_STRING_FORMAT + ".%f"

    def __init__(self, file_name: str = None, header_length: int = 10):
        self._file = file_name
        self._header_length = header_length
        self._site_of_interest = None
        self.file_reader = None
        self._set_file_reader()

    @property
    def sites(self):
        return self._site_of_interest

    def _set_file_reader(self):
        """
        set the good file parser to open and read the provided file
        :return:
        """
        try:
            file_ext = self.file_extension
            if file_ext in self.TXT_FILE_TYPES:
                self.file_reader = file_parser.TXTFileParser(self._file, self._header_length)
            elif file_ext in self.XLS_FILES_TYPES:
                self.file_reader = file_parser.EXCELFileParser(self._file, self._header_length)
            elif file_ext in self.CSV_FILES_TYPES:
                self.file_reader = file_parser.CSVFileParser(self._file, self._header_length)
            elif file_ext in self.WEB_XML_FILES_TYPES:
                self.file_reader = file_parser.WEB_XMLFileParser(self._file)
        except ValueError as e:
            if 'http' in self._file:
                self.file_reader = file_parser.WEB_XMLFileParser(self._file)
            else:
                raise e

        self.file_reader.read_file()

    def read_file(self):
        self._make_site()
        self._make_data()

    @property
    def file_extension(self):
        file_list = self._file.split(".")
        if len(file_list) == 1:
            raise ValueError("The path given doesn't point to a file name")
        if len(file_list) > 2:
            raise ValueError("The file name seems to be corrupted. Too much file extension in the current name")
        else:
            return file_list[-1].lower()

    @property
    def file_content(self):
        return self.file_reader.get_file_content

    def _make_site(self):
        """
        create a site object by reading the file header and the data header to know what
        was recorded by calling
        -   self._read_file_header()
        -   self._read_file_data_header()
        :return:
        """
        self._read_file_header()
        self._read_file_data_header()

    def _make_data(self):
        """
        read and classified the data by calling
        -   self._read_file_data()
        :return:
        """
        self._read_file_data()

    @abstractmethod
    def _read_file_header(self):
        """
        Read the file header
        :return:
        """
        pass

    @abstractmethod
    def _read_file_data_header(self):
        """
        read the data header (what was recorded)
        :return:
        """
        pass

    @abstractmethod
    def _read_file_data(self):
        """
        read and classified the data column
        :return:
        """
        pass


class TimeSeriesFileReader(AbstractFileReader):
    def __init__(self, file_name: str = None, header_length: int = 10):
        super().__init__(file_name, header_length)
        self._site_of_interest = SensorPlateform()
        self._date_list = None

    @property
    def time_series_dates(self):
        return self._date_list

    @abstractmethod
    def _get_date_list(self) -> date_list:
        pass


class GeochemistryFileReader(AbstractFileReader):
    def __init__(self, file_name: str = None,
                 header_length: int = 10):
        super().__init__(file_name, header_length)
        self._site_of_interest = defaultdict(dict)  # dict of Samples
        self.project = None
        self.report_date = None
        self.analysis_methode = None

    def create_sample(self, sample_name: str):
        sample = Sample(site_name=sample_name)
        self._site_of_interest[sample_name] = sample
        yield self._site_of_interest[sample_name]

    def create_complete_sample(self, site_name: str = None,
                               visit_date: datetime.datetime = None,
                               lab_sample_name: str = None,
                               sample_type: str = None,
                               project_name: str = None):
        sample = Sample(site_name, visit_date, lab_sample_name, sample_type, project_name)
        self._site_of_interest[site_name] = sample


class TimeSeriesGeochemistryFileReader(TimeSeriesFileReader, GeochemistryFileReader):
    TIME_SERIES_DATA = 'timeSerie'
    GEOCHEMISTRY_DATA = 'samples'
   
    def __init__(self, file_name: str = None, header_length: int = 10):
        """
        class between TimeSeriesFileReader and GeochemistryFileReader.
        internal data structure is like:
        self._site_of_interest
            [TIMES_SERIES]
                SensorPlateform
            [GEOCHEMISTRY]
                [date : datetime.datetime]
                    [sample_name:str]
                        Sample
       """
        super().__init__(file_name, header_length)
        self._site_of_interest = defaultdict(dict)
        self._site_of_interest[self.TIME_SERIES_DATA] = SensorPlateform()
        self._site_of_interest[self.GEOCHEMISTRY_DATA] = defaultdict(dict)  # dict sorted by [samp_name][samp_date]

    def get_sample_by_date(self, p_date, p_samp_name):
        try:
            return self._site_of_interest[self.GEOCHEMISTRY_DATA][p_date][p_samp_name]
        except:
            return None

    def get_time_series_data(self) -> SensorPlateform:
        return self._site_of_interest[self.TIME_SERIES_DATA]

    def get_geochemistry_data(self) -> dict:
        return self._site_of_interest[self.GEOCHEMISTRY_DATA]

    def _get_date_list(self) -> date_list:
        return self.get_time_series_data().get_unique_dates_for_all_record()

    @property
    def time_series_dates(self):
        self._date_list = self._get_date_list()
        return self._date_list
    
    def makes_samples_with_time_series(self):
        sample_name = self.get_time_series_data().site_name
        project = self.get_time_series_data().project_name
        # iterate through all dates
        for dates in self.time_series_dates:
            # create a sample
            samp = Sample(site_name=sample_name,
                          visit_date=dates,
                          lab_sample_name=None,
                          sample_type='automatic',
                          analysis_type=None,
                          project_name=project)
            # create and add a record to the sample
            for rec in self.get_time_series_data().get_records():
                val = rec.get_value_at_date(dates)
                param = rec.parameter
                unit = rec.parameter_unit
                samp.create_complete_record(dates,param,unit,val,None,dates,None)
            # add the sample to the geochemistry datas
            self.get_geochemistry_data()[dates][sample_name] = samp
    
    def make_time_series_with_samples(self):
        """
        :return:
        """
        treated_samp = []
        current_samp = None
        date_list = list(self.get_geochemistry_data().keys())
        values = []
        samp = None
        for dates in date_list:
            for samp in self.get_geochemistry_data()[dates]:
                current_samp = samp
                
            

# TODO: """create an alternative to SensorPlateform and GeochemistryFileReader to have a time series and samples
#  for each dates in  times series, have a sample (date, param, record(value).
