#######################################################
# 
# Python implementation of the Class SensorFileReader
# Generated by Enterprise Architect
# Created on:      09-Jul-2017 21:09:12
# Original author: Laptop
# 
#######################################################
import datetime
from abc import abstractmethod
from collections import defaultdict

from typing import Dict, List, Union

from site_and_records import *
import file_parser

sample_ana_type = Dict[str, Sample]
sample_dict = Dict[str, sample_ana_type]
date_list = List[datetime.datetime]


class AbstractFileReader(object):
    """Interface permettant de lire un fichier provenant d'un datalogger quelconque
    classe permettant d'extraire des données d'un fichier quelconque.
    Un fichier de donnée est en général composé de :
    - Entete d'information sur l'environnement de prise de données
    - Entete d'information sur les colonnes de données
    - Les colonnes de données
    """
    TXT_FILE_TYPES = ['dat', 'lev']
    XLS_FILES_TYPES = ['xls', 'xlsx']
    CSV_FILES_TYPES = ['csv']
    WEB_XML_FILES_TYPES = ['xle', 'xml', 'http']
    MONTH_S_DAY_S_YEAR_HMS_DATE_STRING_FORMAT = '%m/%d/%y %H:%M:%S'
    YEAR_S_MONTH_S_DAY_HM_DATE_STRING_FORMAT = '%Y/%m/%d %H:%M'
    YEAR_S_MONTH_S_DAY_HMS_DATE_STRING_FORMAT = YEAR_S_MONTH_S_DAY_HM_DATE_STRING_FORMAT + ":%S"
    YEAR_S_MONTH_S_DAY_HMSMS_DATE_STRING_FORMAT = YEAR_S_MONTH_S_DAY_HMS_DATE_STRING_FORMAT + ".%f"

    def __init__(self, file_name: str = None, header_length: int = 10, request_params:dict = None):
        self.request_params = request_params
        self._file = file_name
        self._header_length = header_length
        self._site_of_interest = None
        self.file_reader = None
        self._set_file_reader()

    @property
    def sites(self):
        return self._site_of_interest

    def _set_file_reader(self):
        """
        set the good file parser to open and read the provided file
        :return:
        """
        try:
            file_ext = self.file_extension
            if file_ext in self.TXT_FILE_TYPES:
                self.file_reader = file_parser.TXTFileParser(file_path=self._file,
                                                             header_length=self._header_length)
            elif file_ext in self.XLS_FILES_TYPES:
                self.file_reader = file_parser.EXCELFileParser(file_path=self._file,
                                                               header_length=self._header_length)
            elif file_ext in self.CSV_FILES_TYPES:
                self.file_reader = file_parser.CSVFileParser(file_path=self._file,
                                                             header_length=self._header_length)
            elif file_ext in self.WEB_XML_FILES_TYPES:
                self.file_reader = file_parser.WEB_XMLFileParser(file_path=self._file,requests_params=self.request_params)
        except ValueError as e:
            if 'http' in self._file:
                self.file_reader = file_parser.WEB_XMLFileParser(file_path=self._file,requests_params=self.request_params)
            else:
                raise e

        self.file_reader.read_file()

    def read_file(self):
        self._make_site()
        self._make_data()

    @property
    def file_extension(self):
        file_list = self._file.split(".")
        if len(file_list) == 1:
            raise ValueError("The path given doesn't point to a file name")
        if len(file_list) > 2:
            raise ValueError("The file name seems to be corrupted. Too much file extension in the current name")
        else:
            return file_list[-1].lower()

    @property
    def file_content(self):
        return self.file_reader.get_file_content

    def _make_site(self):
        """
        create a site object by reading the file header and the data header to know what
        was recorded by calling
        -   self._read_file_header()
        -   self._read_file_data_header()
        :return:
        """
        self._read_file_header()
        self._read_file_data_header()

    def _make_data(self):
        """
        read and classified the data by calling
        -   self._read_file_data()
        :return:
        """
        self._read_file_data()

    @abstractmethod
    def _read_file_header(self):
        """
        Read the file header
        :return:
        """
        pass

    @abstractmethod
    def _read_file_data_header(self):
        """
        read the data header (what was recorded)
        :return:
        """
        pass

    @abstractmethod
    def _read_file_data(self):
        """
        read and classified the data column
        :return:
        """
        pass


class TimeSeriesFileReader(AbstractFileReader):
    def __init__(self, file_name: str = None, header_length: int = 10):
        super().__init__(file_name, header_length)
        self._site_of_interest = SensorPlateform()
        self._date_list = None

    @property
    def time_series_dates(self):
        return self._date_list

    @abstractmethod
    def _get_date_list(self) -> date_list:
        pass


class GeochemistryFileReader(AbstractFileReader):
    def __init__(self, file_name: str = None,
                 header_length: int = 10):
        super().__init__(file_name, header_length)
        self._site_of_interest = defaultdict(dict)  # dict of Samples
        self.project = None
        self.report_date = None
        self.analysis_methode = None

    def create_sample(self, sample_name: str):
        sample = Sample(site_name=sample_name)
        self._site_of_interest[sample_name] = sample
        yield self._site_of_interest[sample_name]

    def create_complete_sample(self, site_name: str = None,
                               visit_date: datetime.datetime = None,
                               lab_sample_name: str = None,
                               sample_type: str = None,
                               project_name: str = None):
        sample = Sample(site_name, visit_date, lab_sample_name, sample_type, project_name)
        self._site_of_interest[site_name] = sample


class TimeSeriesGeochemistryFileReader(TimeSeriesFileReader, GeochemistryFileReader):
    TIME_SERIES_DATA = 'timeSerie'
    GEOCHEMISTRY_DATA = 'samples'

    def __init__(self, file_name: str = None, header_length: int = 10):
        """
        class between TimeSeriesFileReader and GeochemistryFileReader.
        internal data structure is like:
        self._site_of_interest
            [TIMES_SERIES]
                [site_name]
                    SensorPlateform
            [GEOCHEMISTRY]
                [date : datetime.datetime]
                    [sample_name:str]
                        Sample
       """
        super().__init__(file_name, header_length)
        self._site_of_interest = defaultdict(dict)
        self._site_of_interest[self.TIME_SERIES_DATA] = defaultdict(SensorPlateform)
        self._site_of_interest[self.GEOCHEMISTRY_DATA] = defaultdict(dict)  # dict sorted by [samp_name][samp_date]

    def get_sample_by_date(self, p_date, p_samp_name) -> Sample:
        try:
            return self._site_of_interest[self.GEOCHEMISTRY_DATA][p_date][p_samp_name]
        except:
            return None

    def get_time_series_data(self, site_name=None) -> Union[SensorPlateform, dict]:
        """
        get all sites avaible that have a time serie OR
        get all timeseries for the given "site_name"
        with this structure:
        [TIMES_SERIES]
            [site_name]
                SensorPlateform
        :param site_name:
        :return:
        """
        if site_name is not None:
            return self._site_of_interest[self.TIME_SERIES_DATA][site_name]
        else:
            return self._site_of_interest[self.TIME_SERIES_DATA]

    def get_geochemistry_data(self) -> dict:
        """
        get the dictionnary for geochemistry in this structure:
        [GEOCHEMISTRY]
            [date : datetime.datetime]
                [sample_name:str]
                    Sample
        :return:
        """
        return self._site_of_interest[self.GEOCHEMISTRY_DATA]

    def _get_date_list(self, site_name) -> date_list:
        """
        get all dates for the given site_name. No matter the parameter
        :param site_name:
        :return:
        """
        return self.get_time_series_data(site_name).get_unique_dates_for_all_record()

    @TimeSeriesFileReader.time_series_dates.getter
    def time_series_dates(self, site_name):
        """
        overide of time_series_dates property getter. Needs to have a site_name because of
        the dict structure
        :param site_name:
        :return:
        """
        self._date_list = self._get_date_list(site_name)
        return self._date_list

    def makes_samples_with_time_series(self, site_name):
        """
        make sample with all the time series for the given site_name
        :param site_name:
        :return:
        """
        sample_name = self.get_time_series_data(site_name).site_name
        project = self.get_time_series_data(site_name).project_name
        # iterate through all dates
        for dates in self._get_date_list(site_name):
            # create a sample
            samp = Sample(site_name=sample_name,
                          visit_date=dates,
                          lab_sample_name=None,
                          sample_type='automatic',
                          analysis_type=None,
                          project_name=project)
            # create and add a record to the sample
            for rec in self.get_time_series_data(site_name).get_records():
                val = rec.get_value_at_date(dates)
                param = rec.parameter
                unit = rec.parameter_unit
                if val is not None:
                    samp.create_complete_record(dates, param, unit, val, None, dates, None)
            # add the sample to the geochemistry datas
            self.get_geochemistry_data()[dates][sample_name] = samp

    def make_time_series_with_samples(self):
        """
        take all the samples in self._site_of_interest[self.GEOCHEMISTRY_DATA]
        and create a time serie for each record.
         After all timeseries are made, they are filled with all the sampling data
        :return:
        """
        self._site_of_interest[self.TIME_SERIES_DATA].clear()
        self._site_of_interest[self.TIME_SERIES_DATA] = defaultdict(SensorPlateform)
        self._create_time_series_with_samples()
        self._fill_time_series_with_samples_data()

    def _create_time_series_with_samples(self):
        """
        create time serie entry for each parameters avaiable for each samples
        remember, geochemistry data structure is like:
        [GEOCHEMISTRY]
            [date : datetime.datetime]
                [sample_name:str]
                    Sample
        :return:
        """
        for sampled_dates in self.get_geochemistry_data().keys():
            for samples_at_date in self.get_geochemistry_data()[sampled_dates].keys():
                for records_in_sample in self.get_sample_by_date(sampled_dates, samples_at_date).get_records():
                    self._add_time_serie_value_by_geochemistry_record(records_in_sample,samples_at_date)

    def _add_time_serie_value_by_geochemistry_record(self, rec, sample_name):
        param = rec.parameter
        unit = rec.parameter_unit
        val = [rec.value]
        val_date = [rec.sampling_date]
        try:
            self.get_time_series_data(sample_name).create_time_serie(param, unit, val_date, val)
        except:
            pass

    def _fill_time_series_with_samples_data(self):
        """
        fill the time series for the given parameter with all the values avaible
        :return:
        """
        for site in self.get_time_series_data():
            for ts in self.get_time_series_data(site).get_records():
                for _dates in self.get_geochemistry_data():
                    rec = self.get_sample_by_date(_dates, site).get_record_by_parameter(ts.parameter)
                    try:
                        ts.add_value(rec.sampling_date, rec.value)
                    except KeyError as k:
                        continue
                    except AttributeError as a:
                        pass
                    except Exception as e:
                        print(type(e))
                        print(e)
                ts.reorder_values()
